$jin.atom - класс реализующий реактивную функционально-императивную парадигму

Условно атомы можно разделить на 3 типа:

• источники (sources) – атомы, которые ни от кого не зависят – их значение меняется императивно в зависимости от каких-либо внешних факторов (например, действия пользователя или пришедшие данные с сервера).

• покрывала (covers) – атомы, которые умеют не только функционально вычислять своё значение, но и императивно его куда-нибудь передавать. Такие используются как конечные звенья дерева зависимостей и как правило от них никто не зависит.

• промежуточные (transits) – все остальные атомы, существование которых обусловлено лишь необходимостью связи покрывал с источниками. Используются для меморизации промежуточных вычислений.

Зависимости между атомами строятся автоматически в момент вычисления их значений. А при повторном вычислении обновляются и зависимости. Каждый атом хранит в себе помимо собственно значения:

• список хозяев (masters)  – атомов, от значений которых непосредственно зависит значение текущего

• список рабов (slaves) – атомов, значения которых непосредственно зависят от значения текущего

• номер слоя (slice) – на 1 больше, чем номера слоёв всех хозяев, или иначе – максимальная дистанция до источников.

Каждый раз, когда реально меняется значение мастера  (сравнение идёт через оператор идентичности `===`) – все рабы получают распоряжение об обновлении, но делают они это не сразу, а отложенно. Причем, чем меньше номер слоя, тем раньше будет вычислено значение атома. Это сделано для того, чтобы не приходилось несколько раз пересчитывать значение атома, пока меняются значения его хозяев.

При инициализации атому передаётся конфиг со следующими опциональными полями:

• pull - функция вычисления значения, по возможности не должна содержать побочных эффектов

• merge - функция слияния нового и старого значений

• push - функция вызываемая при изменении значения, используется для синхронизации с нереактивным миром

Несколько примеров
==================

Таймер, каждую секунду увеличивающий своё значение. Начинает работать лишь когда кто-либо запрашивает его значение.
```js
var tick = $jin.atom(
{   pull: function( prev ){
		setTimeout( function( ){
			tick.pull()
		}, 1000 )
		return ( Number( next ) || 0 ) + 1
	}
})
```
Пример очень простой, не повторяйте это дома (как минимум не хватает возможности его остановки), но для иллюстрации подойдёт.

Отобразим текущее значение таймера в заголовке окна.
```js
var title = $jin.atom(
{   pull: function( ){
		return 'Current tick: ' + tick.get()
	}
,   push: function( next ){
		document.title = next
	}
})
title.update()
```
Теперь у нас заголовок будет каждую секунду обновляться. Но напрямую с атомами работать не очень удобно – требуются объекты со свойствами. И зависимости между этими свойствами было бы не плохо, чтобы тоже отслеживались. Поэтому воспользуемся специальными методами, которые имеют удобный интерфейс, но под капотом создают атомы для каждого объекта по мере необходимости.

```js
var $my = { timer: {} }

$jin.atom.prop({ '$my.timer.tick':
{   pull: function( prev ){
		setTimeout( function( ){
			$my.timer.tickAtom().pull()
		}, 1000 )
		
		return ( Number( next ) || 0 ) + 1
	}
}})

$jin.atom.prop({ '$my.timer.title':
{   pull: function( ){
		return 'Current tick: ' + this.tick()
	}
,   push: function( next ){
		document.title = next
	}
}})

$my.timer.title()
```
Пример из жизни:
```js
$jin.atom.prop({ '$jin.task.view.row..current': {
	pull: function( ){
		return this.list().task() === this.task()
	}
}})
```
current – флаг указывающий, что эта задача сейчас выделена. Вычисляется он просто: берем список в котором отображается задача, смотрим у него текущую задачу и если она совпадает с нашей, значит вьюшку надо выделить как текущую. При этом нам не надо ни подписываться на какие-либо события, ни писать где-либо в другой части приложения код для обновления состояния этой вьюшки. Значение этого свойства всегда остаётся актуальным.

API
===

Простейший атом создаётся просто:
```js
var myName = $jin.atom({})
```
*Параметры конструктора*

Имя атома в контексте вашего приложения, чтобы при дебаге было проще понять что за значение в нём содержится:
```js
name : String
```
Функция вычисления нового значения:
```js
pull( prev )
```
Функция вызываемая сразу после изменения значения (используется, чтобы отразить изменения в не-frp рантайм):
```js
push( next, prev )
```
Функция слияния нового и старого значения (по умолчанию, новое значение просто записывается вместо старого):
```js
merge( next, prev )
```
Контекст в котором будут вызваны упомянутые выше обработчики:
```js
context : Object
```
*Методы экземпляров*

Получить значение атома (если оно ещё не вычислено – сначала вычислить):
```js
$jin.atom..get()
```
Записать новое значение (предварительно слив с текущим):
```js
$jin.atom..put( next ) : $jin.atom
```
Запланировать обновление:
```js
$jin.atom..update() : $jin.atom
```
Немедленно вычислить значение, слить с предыдущим и вернуть его:
```js
$jin.atom..pull()
```
Уведомить рабов, что значение изменилось:
```js
$jin.atom..notify()
```
Возыметь власть над рабом:
```js
$jin.atom..lead( slave : $jin.atom )
```
Приписать к хозяину:
```js
$jin.atom..obey( master : $jin.atom )
```
Выгнать раба:
```js
$jin.atom..dislead( slave : $jin.atom )
```
Отписать от хозяина:
```js
$jin.atom..disobey( master : $jin.atom )
```
Массовая отлинковка:
```js
$jin.atom..disleadAll()
$jin.atom..disobeyAll()
```
Автогенерированный идентификатор:
```js
$jin.atom..id() : String
```
Прямой доступ к текущему значению:
```js
$jin.atom..value()
$jin.atom..value( next )
```
Установлено ли текущее значение:
```js
$jin.atom..define() : Boolean
```
Текущий слой:
```js
$jin.atom..slice() : Number
```
